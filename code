from maix import image, camera, display, app, nn, uart
import cv2
import sys
import struct
import math
import numpy as np
import collections
sys.path.append('/root/exam')
import serial_protocol
detector = nn.Retinaface(model="/root/models/retinaface.mud")
ocr = nn.PP_OCR(model="/root/models/pp_ocr.mud")  # OCR模型
image.load_font("ppocr", "/maixapp/share/font/ppocr_keys_v1.ttf", size=20)
image.set_default_font("ppocr")
comm_proto = serial_protocol.SerialProtocol()
device = "/dev/ttyS0"
serial = uart.UART(device, 115200)
# 图像处理参数
MIN_CONTOUR_AREA = 500  # 轮廓面积范围（根据 ROI 大小调整）
MAX_CONTOUR_AREA = 100000
current_detected_digit = None
# 多边形近似因子
EPSILON_FACTOR = 0.005  # 控制轮廓近似精度，值越小保留细节越多

# 内凹点和直角点检测参数
CONCAVE_DEFECT_THRESHOLD = 500  # 内凹缺陷深度阈值
POINT_MATCH_THRESHOLD = 10  # 点匹配距离阈值

# 空间过滤参数：过滤掉质心在图像边缘区域的轮廓
FILTER_BORDER_PERCENTAGE = 0.05

# 最小显示边长阈值
MIN_DISPLAY_SIDE_LENGTH = 15.0  # 过滤过短的边
# 存储已识别的正方形信息
recognized_squares = []  # 存储格式: [cx, cy, 识别的数字, 是否已标记, 边长]

# 存储当前正在处理的正方形
current_square = None  # 格式: [cx, cy, 宽度, 高度, 连续识别次数, 上次识别的数字]

# 设置目标数字
target_number = "7"  # 可以根据需要修改为您想要匹配的数字
# 边界框边缘过滤阈值：判断边是否为“外部”边
BBOX_EDGE_FILTER_THRESHOLD = 10.0  # 边中点到边界框边缘的最大距离
def is_square1(approx, max_side_diff=30):
    """
    简化版正方形检测：只检查四边形的相邻边长差值是否小于指定像素数
    max_side_diff: 相邻边长最大允许差值（像素）
    返回: (是否为正方形, 平均边长)
    """
    if len(approx) != 4:
        return False, 0
    
    # 获取四个顶点
    points = approx.reshape(-1, 2).astype(np.float32)
    
    # 计算四条边的长度
    sides = []
    for i in range(4):
        p1 = points[i]
        p2 = points[(i + 1) % 4]
        side_length = np.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)
        sides.append(side_length)
    
    # 检查相邻边长差值是否小于阈值
    for i in range(4):
        if abs(sides[i] - sides[(i+1)%4]) > 30:
            #print(f"相邻边长差值过大: {abs(sides[i] - sides[(i+1)%4]):.2f}像素")
            return False, 0
    
    avg_side = np.mean(sides)
    #print(f"正方形检测通过: 边长={[round(s, 2) for s in sides]}, 平均={avg_side:.2f}")
    return True, avg_side
def reset_all_detection_variables():
    global distance_buffer, confirmed_distance, is_distance_confirmed
    global size_history, stable_size, size_locked
    global triangle_size_history, stable_triangle_size, triangle_size_locked
    global circle_size_history, stable_circle_size, circle_size_locked
    global side_size_history, stable_side_size, side_size_locked
    global side_length_history
    
    # Reset distance variables
    distance_buffer = collections.deque(maxlen=10)
    confirmed_distance = None
    is_distance_confirmed = False
    
    # Reset square size variables
    size_history = collections.deque(maxlen=10)
    stable_size = None
    size_locked = False
    
    # Reset triangle size variables
    triangle_size_history = collections.deque(maxlen=10)
    stable_triangle_size = None
    triangle_size_locked = False
    
    # Reset circle size variables
    circle_size_history = collections.deque(maxlen=10)
    stable_circle_size = None
    circle_size_locked = False
    
    # Reset side size variables
    side_size_history = []
    stable_side_size = None
    side_size_locked = False
    
    # Reset side length history
    side_length_history = []
    
    print("All detection variables have been reset")
# --- 辅助函数 ---
def angle_between_points(p1, p2, p3):
    """计算三点形成的角度（p2为顶点），并判断凹凸性。"""
    v1_x, v1_y = p1[0] - p2[0], p1[1] - p2[1]
    v2_x, v2_y = p3[0] - p2[0], p3[1] - p2[1]

    cross_product = v1_x * v2_y - v1_y * v2_x
    concavity = "内凹" if cross_product < 0 else "外凸"

    dot_product = v1_x * v2_x + v1_y * v2_y
    norm_v1_sq = v1_x**2 + v1_y**2
    norm_v2_sq = v2_x**2 + v2_y**2
    
    if norm_v1_sq == 0 or norm_v2_sq == 0:
        return 0, concavity

    norm_v1 = math.sqrt(norm_v1_sq)
    norm_v2 = math.sqrt(norm_v2_sq)

    cos_angle = dot_product / (norm_v1 * norm_v2)
    angle_rad = math.acos(max(-1.0, min(1.0, cos_angle)))
    return math.degrees(angle_rad), concavity

def distance_squared(p1, p2):
    """计算两点距离的平方"""
    return (p2[0] - p1[0])**2 + (p2[1] - p1[1])**2

def distance(p1, p2):
    """计算两点间的实际距离"""
    return math.sqrt(distance_squared(p1, p2))

def get_concave_indices(contour, approx_points):
    """获取内凹点在 approx_points 中的索引"""
    hull_indices = cv2.convexHull(contour, returnPoints=False)
    concave_indices = set()
    
    if hull_indices is not None and len(hull_indices) >= 3:
        try:
            defects = cv2.convexityDefects(contour, hull_indices)
            if defects is not None:
                for i in range(defects.shape[0]):
                    s, e, f, d = defects[i, 0]
                    if d > CONCAVE_DEFECT_THRESHOLD:
                        far_point_original = tuple(contour[f][0])
                        min_dist = float('inf')
                        best_match_idx = -1
                        for idx, p_approx in enumerate(approx_points):
                            dist = distance_squared(far_point_original, p_approx)
                            if dist < min_dist:
                                min_dist = dist
                                best_match_idx = idx
                        
                        if best_match_idx != -1:
                            num_points = len(approx_points)
                            p1 = approx_points[(best_match_idx-1) % num_points]
                            p2 = approx_points[best_match_idx]
                            p3 = approx_points[(best_match_idx+1) % num_points]
                            angle, concavity = angle_between_points(p1, p2, p3)
                            
                            if min_dist < POINT_MATCH_THRESHOLD**2 or (concavity == "内凹" and angle < 150):
                                concave_indices.add(best_match_idx)
        except cv2.error:
            pass 

    num_points = len(approx_points)
    for i in range(num_points):
        p1 = approx_points[(i-1) % num_points]
        p2 = approx_points[i]
        p3 = approx_points[(i+1) % num_points]
        angle, concavity = angle_between_points(p1, p2, p3)
        
        if concavity == "内凹" and angle < 150 and i not in concave_indices:
            concave_indices.add(i)
    
    return concave_indices

# --- 核心图像处理函数 ---
def process_frame_for_complex_squares(frame_np, dynamic_roi=None):
    """
    处理一帧图像，在动态 ROI 内检测凹凸特征并直接在原图上显示边长。
    返回: (检测到的最小边长, 所有检测到的边长)
    """
    # 不再创建输出帧的副本，直接在原图上操作
    min_side_length = float('inf')
    all_detected_sides = []

    # 1. 检查动态 ROI 是否有效
    if dynamic_roi is None:
        print("警告：dynamic_roi 为 None，使用整帧图像处理")
        roi_img = frame_np
        dyn_x, dyn_y = 0, 0
    else:
        dyn_x = dynamic_roi.get('x', 0)
        dyn_y = dynamic_roi.get('y', 0)
        dyn_w = dynamic_roi.get('w', frame_np.shape[1])
        dyn_h = dynamic_roi.get('h', frame_np.shape[0])

        # 验证 ROI 参数
        if (dyn_x < 0 or dyn_y < 0 or 
            dyn_x + dyn_w > frame_np.shape[1] or 
            dyn_y + dyn_h > frame_np.shape[0] or 
            dyn_w <= 0 or dyn_h <= 0):
            print(f"警告：无效的 dynamic_roi 参数: x={dyn_x}, y={dyn_y}, w={dyn_w}, h={dyn_h}")
            return None, None

        print(f"使用动态ROI: x={dyn_x}, y={dyn_y}, w={dyn_w}, h={dyn_h}")
        roi_img = frame_np[dyn_y:dyn_y + dyn_h, dyn_x:dyn_x + dyn_w]

    # 2. 图像预处理（在 ROI 内）
    gray = cv2.cvtColor(roi_img, cv2.COLOR_BGR2GRAY)
    thresh = cv2.adaptiveThreshold(gray, 255, 
                                   cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                   cv2.THRESH_BINARY_INV, 11, 2)

    # 3. 提取 ROI 内轮廓
    contours, _ = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE) 
    candidate_contours = []

    img_height, img_width = frame_np.shape[:2]
    x_min_roi = int(img_width * FILTER_BORDER_PERCENTAGE)
    x_max_roi = int(img_width * (1 - FILTER_BORDER_PERCENTAGE))
    y_min_roi = int(img_height * FILTER_BORDER_PERCENTAGE)
    y_max_roi = int(img_height * (1 - FILTER_BORDER_PERCENTAGE))

    if contours:
        for cnt in contours:
            area = cv2.contourArea(cnt)
            if MIN_CONTOUR_AREA <= area <= MAX_CONTOUR_AREA:
                moments = cv2.moments(cnt)
                if moments["m00"] != 0: 
                    cX, cY = int(moments["m10"]/moments["m00"]), int(moments["m01"]/moments["m00"])
                    # 转换质心坐标到全局坐标
                    global_cX, global_cY = cX + dyn_x, cY + dyn_y
                    if x_min_roi < global_cX < x_max_roi and y_min_roi < global_cY < y_max_roi:
                        candidate_contours.append((cnt, area))

    # 4. 处理每个候选轮廓
    for cnt, area in candidate_contours:
        x_bbox, y_bbox, w_bbox, h_bbox = cv2.boundingRect(cnt)
        # 转换边界框坐标到全局坐标
        bbox_x_min, bbox_y_min = x_bbox + dyn_x, y_bbox + dyn_y
        bbox_x_max, bbox_y_max = x_bbox + w_bbox + dyn_x, y_bbox + h_bbox + dyn_y

        perimeter = cv2.arcLength(cnt, True)
        epsilon = EPSILON_FACTOR * perimeter 
        approx = cv2.approxPolyDP(cnt, epsilon, True)
        # 转换近似点坐标到全局坐标
        approx_points = [(p[0][0] + dyn_x, p[0][1] + dyn_y) for p in approx] 
        num_points = len(approx_points)

        if num_points < 3:
            continue

        concave_indices = get_concave_indices(cnt, approx_points)
        
        right_angle_points_indices = []
        for i in range(num_points):
            p1 = approx_points[(i-1) % num_points]
            p2 = approx_points[i]
            p3 = approx_points[(i+1) % num_points]
            angle, concavity = angle_between_points(p1, p2, p3)
            
            if 80 <= angle <= 100 and concavity == "外凸":
                right_angle_points_indices.append(i)
        
        if len(right_angle_points_indices) >= 2:
            for i in range(len(right_angle_points_indices)):
                idx1 = right_angle_points_indices[i]
                p_start = approx_points[idx1]

                for j in range(i + 1, len(right_angle_points_indices)):
                    idx2 = right_angle_points_indices[j]
                    p_end = approx_points[idx2]

                    has_concave_between = False
                    path1_indices = []
                    current_idx = idx1
                    while current_idx != idx2:
                        path1_indices.append(current_idx)
                        current_idx = (current_idx + 1) % num_points
                    path1_indices.append(idx2) 

                    path2_indices = []
                    current_idx = idx1
                    while current_idx != idx2:
                        path2_indices.append(current_idx)
                        current_idx = (current_idx - 1 + num_points) % num_points
                    path2_indices.append(idx2) 

                    path_to_check = path1_indices if len(path1_indices) <= len(path2_indices) else path2_indices

                    for k in path_to_check:
                        if k != idx1 and k != idx2 and k in concave_indices:
                            has_concave_between = True
                            break

                    if not has_concave_between:
                        mid_point = ((p_start[0] + p_end[0]) // 2, (p_start[1] + p_end[1]) // 2)
                        side_len = distance(p_start, p_end)
                        if side_len >= MIN_DISPLAY_SIDE_LENGTH:
                            # 更新最小边长
                            if side_len < min_side_length:
                                min_side_length = side_len
                            
                            # 添加到所有检测到的边长列表
                            all_detected_sides.append(side_len)
                            
                            min_dist_to_bbox_edge = min(
                                abs(mid_point[0] - bbox_x_min),
                                abs(mid_point[0] - bbox_x_max),
                                abs(mid_point[1] - bbox_y_min),
                                abs(mid_point[1] - bbox_y_max)
                            )
                            if min_dist_to_bbox_edge <= BBOX_EDGE_FILTER_THRESHOLD:
                                text = f"{side_len:.1f}"
                                font = cv2.FONT_HERSHEY_SIMPLEX
                                font_scale = 0.4 
                                thickness = 1    
                                (text_width, text_height), baseline = cv2.getTextSize(text, font, font_scale, thickness)
                                text_org_x = mid_point[0] - text_width // 2
                                text_org_y = mid_point[1] + (text_height + baseline) // 2 
                                cv2.putText(frame_np, text, (text_org_x, text_org_y), 
                                            font, font_scale, (0, 255, 255), thickness)
    
    # 5. 绘制动态 ROI 边界（可选，用于调试）
    if dynamic_roi is not None:
        cv2.rectangle(frame_np, (dyn_x, dyn_y), (dyn_x + dyn_w, dyn_y + dyn_h), (0, 0, 255), 1)

    # 如果没有检测到任何边长，返回None
    if min_side_length == float('inf'):
        min_side_length = None
    
    # 只返回边长信息，不返回图像（因为已经直接修改了原图）
    return min_side_length, all_detected_sides


def sort_corners(points):
    """
    对多边形角点按顺时针方向排序
    points: 输入角点数组，形状为(n, 2)
    返回: 排序后的角点数组
    """
    # 1. 计算质心（中心点）
    centroid = np.mean(points, axis=0)  # 质心坐标 (cx, cy)
    
    # 2. 计算每个点相对于质心的角度（弧度）
    angles = []
    for (x, y) in points:
        # 计算与质心的差值
        dx = x - centroid[0]
        dy = y - centroid[1]
        # 计算角度（atan2返回值范围：[-π, π]）
        angle = np.arctan2(dy, dx)
        angles.append(angle)
    
    # 3. 按角度排序（将角度转换为[0, 2π)范围，确保顺时针排序）
    # 对角度和点进行绑定，按角度升序排序
    sorted_pairs = sorted(zip(angles, points), key=lambda x: x[0])
    # 提取排序后的点
    sorted_points = [p[1] for p in sorted_pairs]
    
    return np.array(sorted_points)
def is_equilateral_triangle(points):
    # Calculate side lengths
    side_1 = math.dist(points[0], points[1])
    side_2 = math.dist(points[1], points[2])
    side_3 = math.dist(points[2], points[0])
    
    # Define a tolerance for side length differences
    tolerance = 10  # Adjust tolerance as needed

    # # Check if all sides are approximately the same length
    # if abs(side_1 - side_2) < tolerance and abs(side_2 - side_3) < tolerance:
    #     average_side_length = (side_1 + side_2 + side_3) / 3
    #     return True, average_side_length  # 返回平均边长
    # return False, 0  # 统一返回元组，避免解包错误
    if abs(side_1 - side_2) < tolerance and abs(side_2 - side_3) < tolerance:
        max_side_length = max(side_1, side_2, side_3)  # 计算最大边长
        return True, max_side_length  # 返回最大边长
    return False, 0  # 统一返回元组，避免解包错误  

# 优化顶点排序函数，确保按顺时针或逆时针顺序排列
def sort_triangle_points(points):
    # 计算质心
    centroid = np.mean(points, axis=0)
    
    # 计算每个点相对于质心的角度
    angles = []
    for point in points:
        dx = point[0] - centroid[0]
        dy = point[1] - centroid[1]
        angle = math.atan2(dy, dx)
        angles.append(angle)
    
    # 根据角度排序点，实现顺时针或逆时针排序
    sorted_indices = np.argsort(angles)
    sorted_points = points[sorted_indices]
    
    # 确定顶部顶点（y值最小的点）
    top_index = np.argmin(sorted_points[:, 1])
    
    # 重新排列，使顶部顶点成为第一个点
    reordered_points = np.roll(sorted_points, -top_index, axis=0)
    
    return reordered_points

def is_square(approx, side_tolerance=0.2, angle_tolerance=10, aspect_ratio_tolerance=0.15):
    """
    严格判断四边形是否为正方形
    side_tolerance: 边长差异容忍度（0-1之间，默认10%）
    angle_tolerance: 角度容忍度（度数，默认±10度）
    aspect_ratio_tolerance: 长宽比容忍度（默认15%）
    """
    if len(approx) != 4:
        return False
    
    # 获取四个顶点
    points = approx.reshape(-1, 2).astype(np.float32)
    
    # 方法1: 检查边长是否相等
    sides = []
    for i in range(4):
        p1 = points[i]
        p2 = points[(i + 1) % 4]
        side_length = np.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)
        sides.append(side_length)
    
    # 检查四条边长度是否相近
    avg_side = np.mean(sides)
    if avg_side < 10:  # 避免太小的形状
        return False
        
    for side in sides:
        if abs(side - avg_side) / avg_side > side_tolerance:
            print(f"边长不符合: {sides}, 平均: {avg_side:.2f}")
            return False
    
    # 方法2: 检查外接矩形的长宽比
    rect = cv2.minAreaRect(approx)
    width, height = rect[1]
    if width == 0 or height == 0:
        return False
        
    aspect_ratio = max(width, height) / min(width, height)
    if abs(aspect_ratio - 1.0) > aspect_ratio_tolerance:
        print(f"长宽比不符合: {aspect_ratio:.2f}")
        return False
    
    # 方法3: 检查角度是否接近90度
    angles = []
    for i in range(4):
        p1 = points[i]
        p2 = points[(i + 1) % 4]
        p3 = points[(i + 2) % 4]
        
        # 计算向量
        v1 = p1 - p2
        v2 = p3 - p2
        
        # 避免零向量
        norm1 = np.linalg.norm(v1)
        norm2 = np.linalg.norm(v2)
        if norm1 == 0 or norm2 == 0:
            continue
            
        # 计算角度
        cos_angle = np.dot(v1, v2) / (norm1 * norm2)
        cos_angle = np.clip(cos_angle, -1, 1)
        angle = np.arccos(cos_angle) * 180 / np.pi
        angles.append(angle)
    
    if len(angles) < 4:
        return False
        
    for angle in angles:
        if abs(angle - 90) > angle_tolerance:
            print(f"角度不符合: {angles}")
            return False
    
    # 方法4: 检查对角线长度是否相等
    diag1 = np.sqrt((points[0][0] - points[2][0])**2 + (points[0][1] - points[2][1])**2)
    diag2 = np.sqrt((points[1][0] - points[3][0])**2 + (points[1][1] - points[3][1])**2)
    
    if abs(diag1 - diag2) / max(diag1, diag2) > side_tolerance:
        print(f"对角线不相等: {diag1:.2f}, {diag2:.2f}")
        return False
    
    print(f"正方形检测通过: 边长={sides}, 角度={angles}, 长宽比={aspect_ratio:.2f}")
    return True, avg_side  # 返回平均边长
def is_point_near_recognized(cx, cy, threshold=20):
    """检查点是否靠近已识别的正方形"""
    for square in recognized_squares:
        sq_x, sq_y = square[0], square[1]
        if abs(cx - sq_x) < threshold and abs(cy - sq_y) < threshold:
            return True
    return False

def process_ocr_in_roi(img, x, y, w, h):
    """在指定ROI区域内进行OCR处理"""
    # 确保ROI在图像范围内
    img_width, img_height = img.size()
    x = max(0, min(x, img_width - 1))
    y = max(0, min(y, img_height - 1))
    w = min(w, img_width - x)
    h = min(h, img_height - y)
    
    # 裁剪图像
    roi_img = img.crop(x, y, w, h)
    
    # 在原图上绘制ROI区域
    img.draw_rect(x, y, w, h, color=image.COLOR_GREEN)
    
    try:
        # 转换图像格式从RGB到BGR
        roi_cv = image.image2cv(roi_img)
        roi_bgr = image.cv2image(roi_cv)  # 转换回maix图像格式，但现在是BGR格式
        
        # 对裁剪后的图像进行OCR检测
        objs = ocr.detect(roi_bgr)
        
        # 如果检测到文本，返回第一个文本
        if len(objs) > 0:
            return img, objs[0].char_str()
    except Exception as e:
        print(f"OCR检测错误: {e}")
    
    return img, None

# 变量用于存储找到的目标正方形边长
target_square_side_length = None
# 计算两点间距离（宽度）
def calc_distance(x1, y1, x2, y2):
    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)

# 计算比例系数k（宽度×距离）
def calc_k(width, distance):
    return width * distance

# 计算目标距离（k÷检测宽度）
def calc_target_distance(width, k):
    return k / width

# 计算正方形边长对应的实际尺寸
def calc_real_size(pixel_size, distance_mm):
    """
    根据正方形的像素边长和距离，计算实际边长
    pixel_size: 像素边长
    distance_mm: 距离（毫米）
    返回: 实际边长（毫米）
    """
    # 使用相机标定参数或经验公式
    # 这里使用简化的线性关系：实际尺寸 = 像素尺寸 * 距离系数
    # 距离系数需要根据实际相机参数调整
    distance_factor = distance_mm / 1000.0  # 转换为米
    # 假设在1米距离时，1个像素约等于1mm（需要根据实际情况校准）
    real_size = pixel_size * distance_factor * 0.5  # 0.5是经验系数，需要校准
    return real_size
# 初始化模型、摄像头、显示器
detector = nn.Retinaface(model="/root/models/retinaface.mud")
cam = camera.Camera(640,480)
disp = display.Display()
detected_width=1
# 初始化串口通信（本版本不发送）
comm_proto = serial_protocol.SerialProtocol()
uart_device = "/dev/ttyS0"
serial_port = uart.UART(uart_device, 115200)
side_length_history = []
# 闭运算卷积核（用于图像预处理）
morph_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))

# 已知参考物体的参数（用于距离计算）
REFERENCE_WIDTH_MM = 68  # 参考物体实际宽度（毫米）
REFERENCE_DISTANCE_MM = 15000  # 参考距离（毫米）
K_VALUE = calc_k(REFERENCE_WIDTH_MM, REFERENCE_DISTANCE_MM)  # 比例系数
# 在类或函数外部初始化
distance_buffer = collections.deque(maxlen=10)
confirmed_distance = None
is_distance_confirmed = False
size_history = collections.deque(maxlen=10)
stable_size = None
size_locked = False
triangle_size_history = collections.deque(maxlen=10)
stable_triangle_size = None
triangle_size_locked = False
circle_size_history = collections.deque(maxlen=10)
stable_circle_size = None
circle_size_locked = False
side_size_history = []  # 边长尺寸历史记录
side_size_locked = False  # 边长尺寸是否已锁定
stable_side_size = None  # 稳定的边长尺寸
data=[]
while not app.need_exit():
    print('data',data)
    length = serial.available()
    if length:
        data = serial.read()
    if data == b'0':
        target_number = "0"
    if data == b'1':
        target_number = "1"    
    if data == b'2':
        target_number = "2"
    if data == b'3':
        target_number = "3"
    if data == b'4':
        target_number = "4"
    if data == b'5':
        target_number = "5"
    if data == b'6':
        target_number = "6"
    if data == b'7':
        target_number = "7"
    if data == b'8':
        target_number = "8"
    if data == b'9':
        target_number = "9"

    # 读取图像并转换格式
    img_frame = cam.read()
    img_maix = img_frame  # 保留原始maix图像用于OCR
    img_bgr = image.image2cv(img_frame, copy=False)

    # 定义感兴趣区域 (ROI): 80% 正方形，居中
    height, width = img_bgr.shape[:2]  # 240x320
    roi_size = int(min(width, height) * 0.8)  # 192
    roi_x = (width - roi_size) // 2   # 64
    roi_y = (height - roi_size) // 2  # 24
    roi = img_bgr[roi_y:roi_y + roi_size, roi_x:roi_x + roi_size]

    # 图像预处理：灰度→闭运算→边缘检测（仅在 ROI 内）
    img_gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)
    img = cv2.GaussianBlur(img_gray, (5, 5), 0)
    #img = cv2.bilateralFilter(img_gray, 9, 30, 30)
    img = cv2.morphologyEx(img, cv2.MORPH_CLOSE, morph_kernel)
    #img = cv2.GaussianBlur(img_closed, (5, 5), 0)
    img_edges = cv2.Canny(img, 50, 150)
    
    # 查找所有轮廓（仅在 ROI 内）
    contours, _ = cv2.findContours(img_edges, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

    # 初始化 dynamic_roi 为 None
    dynamic_roi = None

    if contours:
       # 筛选出符合条件的轮廓
        valid_contours = []
        
        # 在处理轮廓之前添加条件判断
        if data == b'\x04':
            print('4')
            # 在 data=4 模式下，跳过矩形验证，直接处理所有四边形轮廓
            for contour in contours:
                contour_area = cv2.contourArea(contour)

                if contour_area >= 500:
                    # 多边形逼近
                    epsilon = 0.02 * cv2.arcLength(contour, True)
                    approx_corners = cv2.approxPolyDP(contour, epsilon, True)

                    if len(approx_corners) == 4:
                        # 排序角点（坐标调整回原图像）
                        corners = approx_corners.reshape(4, 2).astype(np.float32)
                        corners[:, 0] += roi_x  # x 偏移
                        corners[:, 1] += roi_y  # y 偏移
                        sum_vals = corners.sum(axis=1)
                        tl, br = corners[np.argmin(sum_vals)], corners[np.argmax(sum_vals)]
                        diff_vals = np.diff(corners, axis=1)
                        tr, bl = corners[np.argmin(diff_vals)], corners[np.argmax(diff_vals)]

                        # 计算各边长度
                        top_edge = calc_distance(tl[0], tl[1], tr[0], tr[1])
                        bottom_edge = calc_distance(bl[0], bl[1], br[0], br[1])
                        left_edge = calc_distance(tl[0], tl[1], bl[0], bl[1])
                        right_edge = calc_distance(tr[0], tr[1], br[0], br[1])
                        
                        # 防止除零错误，检查边长是否为零
                        if any(edge == 0 for edge in [top_edge, bottom_edge, left_edge, right_edge]):
                            continue
                        if left_edge>1.25*bottom_edge:
                            
                            valid_contours.append({
                                'contour': contour,
                                'area': contour_area,
                                'corners': corners,
                                'tl': tl, 'tr': tr, 'bl': bl, 'br': br
                            })
                            print('666')
        else:
            # 原有的矩形验证逻辑
            for contour in contours:
                contour_area = cv2.contourArea(contour)

                if contour_area >= 500:
                    # 多边形逼近
                    epsilon = 0.01 * cv2.arcLength(contour, True)
                    approx_corners = cv2.approxPolyDP(contour, epsilon, True)

                    if len(approx_corners) == 4:
                    # 排序角点（坐标调整回原图像）
                        corners = approx_corners.reshape(4, 2).astype(np.float32)
                        corners[:, 0] += roi_x  # x 偏移
                        corners[:, 1] += roi_y  # y 偏移
                        sum_vals = corners.sum(axis=1)
                        tl, br = corners[np.argmin(sum_vals)], corners[np.argmax(sum_vals)]
                        diff_vals = np.diff(corners, axis=1)
                        tr, bl = corners[np.argmin(diff_vals)], corners[np.argmax(diff_vals)]

                        # 计算各边长度
                        top_edge = calc_distance(tl[0], tl[1], tr[0], tr[1])
                        bottom_edge = calc_distance(bl[0], bl[1], br[0], br[1])
                        left_edge = calc_distance(tl[0], tl[1], bl[0], bl[1])
                        right_edge = calc_distance(tr[0], tr[1], br[0], br[1])                    
                        # 判断矩形条件：上边≈下边，左边≈右边（误差不超过10像素）
                        top_bottom_diff = abs(top_edge - bottom_edge)
                        left_right_diff = abs(left_edge - right_edge)
                        # 新增：防止除零错误，检查边长是否为零
                        if any(edge == 0 for edge in [top_edge, bottom_edge, left_edge, right_edge]):
                            continue
                        # 计算上边与侧边的比值
                        aspect_ratio1 = top_edge / left_edge
                        aspect_ratio2 = top_edge / right_edge
                        
                        # 判断是否满足条件：上下边相等，左右边相等（误差<10），上边/侧边≈0.7
                        is_valid_rectangle = (top_bottom_diff < 10 and 
                                            left_right_diff < 10 and
                                            abs(aspect_ratio1 - 0.7) < 0.15 and
                                            abs(aspect_ratio2 - 0.7) < 0.15)
                        
                        if is_valid_rectangle:
                            # 将符合条件的轮廓及其面积和角点信息保存
                            valid_contours.append({
                                'contour': contour,
                                'area': contour_area,
                                'corners': corners,
                                'tl': tl, 'tr': tr, 'bl': bl, 'br': br
                            })


        # 如果有符合条件的轮廓
        if valid_contours:
            # 按面积从小到大排序
            valid_contours.sort(key=lambda x: x['area'])
            
            # 选择面积最小的轮廓
            smallest_contour = valid_contours[0]
            
            # 提取角点信息
            corners = smallest_contour['corners']
            tl, tr, bl, br = smallest_contour['tl'], smallest_contour['tr'], smallest_contour['bl'], smallest_contour['br']
            left_edge = calc_distance(tl[0], tl[1], bl[0], bl[1])
            right_edge = calc_distance(tr[0], tr[1], br[0], br[1])
            # 计算侧边平均值
            side_edge_avg = (left_edge + right_edge) / 2
            print(f"侧边平均值: {side_edge_avg:.2f}px")
            # 中心点
            # moments = cv2.moments(smallest_contour['contour'])
            # if moments["m00"] != 0:
            #     center_x = int(moments["m10"] / moments["m00"]) + roi_x
            #     center_y = int(moments["m01"] / moments["m00"]) + roi_y
            #     cv2.circle(img_bgr, (center_x, center_y), 5, (0, 0, 255), -1)
            # 计算宽度和距离
            # 计算宽度和距离
            detected_width = calc_distance(br[0], br[1], bl[0], bl[1])
            print(tl, tr, bl, br)
            print(br[0], br[1], bl[0], bl[1])
            k_val = calc_k(110, 15000)  
            target_dist = calc_target_distance(detected_width, k_val)

            print(f"检测宽度: {detected_width:.2f}px")
            print(f"比例系数k: {k_val}")
            print(f"目标距离: {target_dist:.2f}mm")
            # 重新计算 top_edge 等以避免作用域问题
            top_edge = calc_distance(tl[0], tl[1], tr[0], tr[1])
            print(f"上边/左边: {top_edge/left_edge:.2f}, 上边/右边: {top_edge/right_edge:.2f}")
            print(f"轮廓面积: {smallest_contour['area']:.2f}px²")
            target_dist = target_dist/100  # 转换为cm

            # 添加当前距离到缓冲区
            distance_buffer.append(target_dist)
            print('2', distance_buffer)

            # 保持缓冲区最多3个值
            if len(distance_buffer) > 3:
                distance_buffer.popleft()  # 移除最旧的值

            # 检查当前缓冲区中的距离稳定性
            distances = list(distance_buffer)
            max_diff = max(distances) - min(distances)

            if max_diff <= 0.5:  # 距离变动不超过0.5cm
                # 直接发送当前检测到的距离
                serial.write(f"D:({target_dist:.2f})".encode('utf-8'))
                print(f"距离稳定，发送当前值: {target_dist:.2f}cm")
                
                # 更新确认距离
                confirmed_distance = target_dist
                is_distance_confirmed = True
            else:
                # 距离变动超过0.5cm，等待稳定
                print(f"距离变动: {max_diff:.2f}cm，等待稳定")
                is_distance_confirmed = False


            #绘制轮廓与距离
            #cv2.drawContours(img_bgr, [corners.astype(np.int32).reshape(-1, 1, 2)], 0, (0, 255, 0), 2)
            cv2.putText(img_bgr, f" {target_dist:.1f}cm",
                        (20, 20),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 0), 2)

            # 绘制角点编号
            corner_list = [tl, tr, br, bl]
            corner_labels = ["1", "2", "3", "4"]
            for i, (x, y) in enumerate(corner_list):
                cv2.circle(img_bgr, (int(x), int(y)), 5, (255, 0, 0), 2)
                cv2.putText(img_bgr, corner_labels[i],
                            (20, 10),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)

            # 新增：计算基于 smallest_contour 的动态 ROI (bounding rect + padding)
            x, y, w, h = cv2.boundingRect(smallest_contour['contour'])
            padding = 2  # 添加一些 padding 以确保完整
            dynamic_roi = {
                'x': max(0, x + padding) + roi_x,  # 调整回原图像坐标
                'y': max(0, y + padding) + roi_y,
                'w': min(width - x-padding, w - 2 * padding),
                'h': min(height - y-padding, h - 2 * padding)
            }


    
        # 处理所有轮廓，寻找正方形
        for contour in contours: 
            # 圆度阈值
            min_circularity = 0.85
            # 过滤掉太小的轮廓
            area = cv2.contourArea(contour)
            perimeter = cv2.arcLength(contour, True)
            if perimeter < 50 or area < 50:
                continue
            if area < 100:  # 提高最小面积阈值
                continue
                
            # 计算参数，多边形逼近
            epsilon = 0.03 * cv2.arcLength(contour, True) 
            approx = cv2.approxPolyDP(contour, epsilon, True)  
            if data == b'\x01':
                # 只处理四边形
                if len(approx) == 4:


                    # 修正is_square函数调用参数（原代码传入了错误的坐标参数）
                    square_result = is_square(approx)
                    if isinstance(square_result, tuple) and square_result[0]:
                        corners = approx.reshape(4, 2).astype(np.float32)
                        corners[:, 0] += roi_x  # x 偏移
                        corners[:, 1] += roi_y  # y 偏移
                        sum_vals = corners.sum(axis=1)
                        tl, br = corners[np.argmin(sum_vals)], corners[np.argmax(sum_vals)]
                        diff_vals = np.diff(corners, axis=1)
                        tr, bl = corners[np.argmin(diff_vals)], corners[np.argmax(diff_vals)]
                        # 正方形处理
                        is_square_flag, avg_side_length = square_result
                        M = cv2.moments(approx)
                        if M["m00"] != 0:
                            cx = int(M["m10"] / M["m00"]) + roi_x  # 添加ROI的x偏移
                            cy = int(M["m01"] / M["m00"]) + roi_y  # 添加ROI的y偏移
                            cv2.circle(img_bgr, (cx, cy), 5, (0, 0, 255), -1)
                            # 计算正方形的实际距离（使用边长）
                            square_distance = calc_target_distance(avg_side_length, K_VALUE)
                            print(avg_side_length)
                            # 计算正方形的实际尺寸
                            real_size = ((avg_side_length / detected_width) * 17)if detected_width != 0 else 0
                            # 添加当前尺寸到历史记录
                            size_history.append(real_size)

                            # 尺寸稳定性检测
                            if not size_locked:
                                if len(size_history) == 10:
                                    size_list = list(size_history)
                                    size_range = max(size_list) - min(size_list)

                                    if size_range <= 0.5:  
                                        stable_size = sum(size_list) / len(size_list)
                                        size_locked = True
                                        print(f"尺寸锁定: {stable_size:.2f}mm")
                                        serial.write(f"X:({real_size:.2f})".encode('utf-8'))  # 发送当前实时尺寸
                            else:
                                # 如果尺寸变动小于0.2cm (2mm)，持续发送当前实时尺寸
                                if abs(real_size - stable_size) <= 2.0:
                                    print(f"尺寸稳定，持续发送当前尺寸: {real_size:.2f}mm")
                                    serial.write(f"X:({real_size:.2f})".encode('utf-8'))  # 发送当前实时尺寸
                                # 如果尺寸变动超过1cm (10mm)，停止发送并重新检测
                                elif abs(real_size - stable_size) > 10.0:
                                    print("尺寸变动超过1cm，重新检测")
                                    size_locked = False
                                    stable_size = None
                                    size_history.clear()
                                # 尺寸变动在0.2cm到1cm之间，不发送但保持锁定状态
                                else:
                                    print(f"尺寸变动在允许范围内，暂停发送: {real_size:.2f}mm")

                            cv2.putText(img_bgr, f"Real: {real_size:.1f}mm", (20, 40), 
                                    cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0, 255, 255), 1)
                                                    
                        # 发送数据
                        offset_approx = approx.copy()  # 复制轮廓用于坐标偏移
                        offset_approx[:, :, 0] += roi_x  # x坐标偏移
                        offset_approx[:, :, 1] += roi_y  # y坐标偏移
                        points = offset_approx.reshape(-1, 2)
                        
                        # print("="*50)
                        # print("Square detected:")
                        # print(f"  像素边长1: {detected_width:.2f} px")
                        # print(f"  像素边长: {avg_side_length:.2f} px")
                        # print(f"  估算距离: {square_distance:.2f} mm")
                        print(f"  实际尺寸: {real_size:.2f} mm")
                        # print(f"  顶点坐标: {points}")
                        # print("="*50)
                        
                        # 绿色粗线标注正方形
                        cv2.drawContours(img_bgr, [offset_approx], 0, (0, 255, 0), 3) 
                        
                        # 标注顶点
                        for i, point in enumerate(offset_approx):
                            x, y = point.ravel()
                            cv2.circle(img_bgr, (x, y), 8, (255, 0, 0), 2)
                            cv2.putText(img_bgr, str(i+1), (x-5, y-10), 
                                    cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 0), 2)
                    
                    elif isinstance(square_result, bool) and square_result:
                        # 兼容原来的返回格式
                        M = cv2.moments(approx)
                        if M["m00"] != 0:
                            cx = int(M["m10"] / M["m00"]) + roi_x
                            cy = int(M["m01"] / M["m00"]) + roi_y
                            cv2.circle(img_bgr, (cx, cy), 5, (0, 0, 255), -1)
                            cv2.putText(img_bgr, "SQUARE", (cx-30, cy-20), 
                                    cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 2)
                        
                        offset_approx = approx.copy()
                        offset_approx[:, :, 0] += roi_x
                        offset_approx[:, :, 1] += roi_y
                        points = offset_approx.reshape(-1, 2)
                        print("Square detected:", points)
                        
                        cv2.drawContours(img_bgr, [offset_approx], 0, (0, 255, 0), 3) 
                        
                        for point in offset_approx:
                            x, y = point.ravel()
                            cv2.circle(img_bgr, (x, y), 8, (255, 0, 0), 2)
            if data == b'\x02':
                if len(approx) == 3:  # Check for triangles
                    points = approx.reshape(-1, 2)  # Convert to (n, 2) array
                    
                    # 只调用一次函数
                    is_equilateral, average_side_length = is_equilateral_triangle(points)
                    
                    if is_equilateral and detected_width!=0:  # 如果是等边三角形
                        print(f"等边三角形边长: {average_side_length:.2f} 像素")
                        
                        # 优化顶点排序
                        sorted_points = sort_triangle_points(points)
                        
                        # 顶点标签（1, 2, 3）
                        labels = ["1", "2", "3"]
                        
                        # 计算中心点（坐标调整回原图像）
                        M = cv2.moments(approx)
                        if M["m00"] != 0:
                            cx = int(M["m10"] / M["m00"]) + roi_x  # 添加ROI的x偏移
                            cy = int(M["m01"] / M["m00"]) + roi_y  # 添加ROI的y偏移
                            cv2.circle(img_bgr, (cx, cy), 5, (0, 0, 255), -1)
                            
                        # 计算三角形的实际距离（使用边长）
                        triangle_distance = calc_target_distance(average_side_length, K_VALUE)

                        # 计算三角形的实际尺寸（使用与正方形相同的比例关系）
                        triangle_real_size = ((average_side_length / detected_width) * 17) if detected_width != 0 else 0
                        # 添加当前三角形尺寸到历史记录
                        triangle_size_history.append(triangle_real_size)

                        # 三角形尺寸稳定性检测
                        if not triangle_size_locked:
                            if len(triangle_size_history) == 10:
                                triangle_size_list = list(triangle_size_history)
                                triangle_size_range = max(triangle_size_list) - min(triangle_size_list)

                                if triangle_size_range <= 5.0:  # 0.5cm = 5mm
                                    stable_triangle_size = sum(triangle_size_list) / len(triangle_size_list)
                                    triangle_size_locked = True
                                    print(f"三角形尺寸锁定: {stable_triangle_size:.2f}mm")
                                    serial.write(f"X:({triangle_real_size:.2f})".encode('utf-8'))  # 发送当前实时尺寸
                        else:
                            # 如果尺寸变动小于0.2cm (2mm)，持续发送当前实时尺寸
                            if abs(triangle_real_size - stable_triangle_size) <= 2.0:
                                print(f"三角形尺寸稳定，持续发送当前尺寸: {triangle_real_size:.2f}mm")
                                serial.write(f"X:({triangle_real_size:.2f})".encode('utf-8'))
                            # 如果尺寸变动超过1cm (10mm)，停止发送并重新检测
                            elif abs(triangle_real_size - stable_triangle_size) > 10.0:
                                print("三角形尺寸变动超过1cm，重新检测")
                                triangle_size_locked = False
                                stable_triangle_size = None
                                triangle_size_history.clear()
                            # 尺寸变动在0.2cm到1cm之间，不发送但保持锁定状态
                            else:
                                print(f"三角形尺寸变动在允许范围内，暂停发送: {triangle_real_size:.2f}mm")

                        # 显示实际尺寸
                        cv2.putText(img_bgr, f"Real: {triangle_real_size:.1f}mm", (20, 40), 
                                cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0, 255, 255), 1)

                        # Draw the triangle and highlight the points
                        offset_approx = approx.copy()  # 复制轮廓用于坐标偏移
                        offset_approx[:, :, 0] += roi_x  # x坐标偏移
                        offset_approx[:, :, 1] += roi_y  # y坐标偏移
                        cv2.drawContours(img_bgr, [offset_approx], 0, (0, 255, 0), 2)
                        
                        # 标记所有顶点并添加标签
                        for i, point in enumerate(sorted_points):
                            x, y = point
                            x += roi_x  # 添加ROI的x偏移
                            y += roi_y  # 添加ROI的y偏移
                            color = (0, 0, 255) if i == 0 else (255, 0, 0)  # 第一个点为红色，其余为蓝色
                            cv2.circle(img_bgr, (int(x), int(y)), 8, color, -1)
                            cv2.putText(img_bgr, labels[i], (int(x)+10, int(y)-10), 
                                        cv2.FONT_HERSHEY_SIMPLEX, 0.7, color, 2)
                        
                        # # 显示三角形信息
                        # cv2.putText(img_bgr, f"边长: {average_side_length:.1f}px", 
                        #         (20, 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 1) 
                        
                        # print("="*50)
                        # print("Equilateral Triangle detected:")
                        # print(f"  三角形像素边长: {average_side_length:.2f} px")
                        # print(f"  估算距离: {triangle_distance:.2f} mm")
                        # print(f"  实际尺寸: {real_size:.2f} mm")
                        # print(f"  顶点坐标: {offset_approx.reshape(-1, 2)}")
                        # print("="*50)
            if data == b'\x03':
                # 计算圆度(该指标是度量区域形状接近圆形的指标，值越接近1，形状越接近圆形)
                circularity = 4 * np.pi * area / (perimeter**2)
                if circularity > min_circularity:
                    # 最优椭圆拟合(内部采用最小二乘法进行拟合计算)
                    center, axes, angle = cv2.fitEllipse(contour)
                    
                    # 添加ROI偏移量
                    center = (center[0] + roi_x, center[1] + roi_y)
                    major_axis = max(axes)  # 长轴作为直径
                    minor_axis = min(axes)  # 短轴
                    
                    # 计算圆的半径（取长短轴平均值）
                    radius = (major_axis + minor_axis) / 4  # 除以2得到半径，再取平均
                    
                    # 计算圆的实际距离
                    circle_distance = calc_target_distance(major_axis, K_VALUE)

                    # 计算圆的实际尺寸（直径）
                    circle_real_size = ((major_axis / detected_width) * 16.5) if detected_width != 0 else 0
                    # 添加当前圆形尺寸到历史记录
                    circle_size_history.append(circle_real_size)

                    # 圆形尺寸稳定性检测
                    if not circle_size_locked:
                        if len(circle_size_history) == 10:
                            circle_size_list = list(circle_size_history)
                            circle_size_range = max(circle_size_list) - min(circle_size_list)

                            if circle_size_range <= 5.0:  # 0.5cm = 5mm
                                stable_circle_size = sum(circle_size_list) / len(circle_size_list)
                                circle_size_locked = True
                                print(f"圆形尺寸锁定: {stable_circle_size:.2f}mm")
                                serial.write(f"X:({circle_real_size:.2f})".encode('utf-8'))  # 发送当前实时尺寸
                    else:
                        # 如果尺寸变动小于0.2cm (2mm)，持续发送当前实时尺寸
                        if abs(circle_real_size - stable_circle_size) <= 2.0:
                            print(f"圆形尺寸稳定，持续发送当前尺寸: {circle_real_size:.2f}mm")
                            serial.write(f"X:({circle_real_size:.2f})".encode('utf-8'))
                        # 如果尺寸变动超过1cm (10mm)，停止发送并重新检测
                        elif abs(circle_real_size - stable_circle_size) > 10.0:
                            print("圆形尺寸变动超过1cm，重新检测")
                            circle_size_locked = False
                            stable_circle_size = None
                            circle_size_history.clear()
                        # 尺寸变动在0.2cm到1cm之间，不发送但保持锁定状态
                        else:
                            print(f"圆形尺寸变动在允许范围内，暂停发送: {circle_real_size:.2f}mm")

                    # 画椭圆并标识圆心
                    cv2.ellipse(img_bgr, (center, axes, angle), (0, 255, 0), 1)
                    cv2.drawMarker(img_bgr, 
                    (int(center[0]), int(center[1])), 
                    (255, 0, 0),  # 蓝色(BGR)
                    markerType=cv2.MARKER_CROSS, 
                    markerSize=10, 
                    thickness=2)

                    # 显示圆的信息
                    cv2.putText(img_bgr, f"Real: {circle_real_size:.1f}mm", 
                            (20,40),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 2)

                    
                    # print("="*50)
                    # print("Circle detected:")
                    # print(f"  圆心坐标: {center}")
                    # print(f"  长轴: {major_axis:.2f} px, 短轴: {minor_axis:.2f} px")
                    # print(f"  估算距离: {circle_distance:.2f} mm")
                    # print(f"  实际尺寸: {real_size:.2f} mm")
                    # print("="*50)
            if data == b'\x04':#倾斜
                # 收集所有符合条件的轮廓
                valid_contours = []
                for contour in contours:
                    area = cv2.contourArea(contour)
                    # 只保留面积大于500的轮廓
                    if area > 500:
                        valid_contours.append((contour, area))
                
                # 如果有符合条件的轮廓，选择面积最小的那个
                if valid_contours:
                    # 按面积从小到大排序，取最小的
                    valid_contours.sort(key=lambda x: x[1])
                    smallest_contour, smallest_area = valid_contours[0]
                    
                    # 对最小轮廓进行多边形逼近
                    epsilon = 0.02 * cv2.arcLength(smallest_contour, True)
                    approx = cv2.approxPolyDP(smallest_contour, epsilon, True)
                    
                    if len(approx) == 4:
                        print('4')
                        
                        # 计算并标注矩形中心点
                        M = cv2.moments(approx)
                        if M["m00"] != 0:
                            # 添加ROI偏移
                            cx = int(M["m10"] / M["m00"]) + roi_x
                            cy = int(M["m01"] / M["m00"]) + roi_y
                            cv2.circle(img_bgr, (cx, cy), 5, (0, 0, 255), -1)  # 用红色标注中心点
                        
                        # 转换形状并添加ROI偏移
                        offset_approx = approx.copy()
                        offset_approx[:, :, 0] += roi_x  # x坐标偏移
                        offset_approx[:, :, 1] += roi_y  # y坐标偏移
                        points = offset_approx.reshape(-1, 2)
                        print(points)
                        # 使用points变量（已定义）替代未定义的corners变量
                        sum_vals = points.sum(axis=1)
                        tl, br = points[np.argmin(sum_vals)], points[np.argmax(sum_vals)]
                        diff_vals = np.diff(points, axis=1)
                        tr, bl = points[np.argmin(diff_vals)], points[np.argmax(diff_vals)]
                        print('1',tl, tr,br, bl)
                        # 计算各边长度
                        top_edge = calc_distance(tl[0], tl[1], tr[0], tr[1])
                        bottom_edge = calc_distance(bl[0], bl[1], br[0], br[1])
                        left_edge = calc_distance(tl[0], tl[1], bl[0], bl[1])
                        right_edge = calc_distance(tr[0], tr[1], br[0], br[1])
                        dff1 = (right_edge + left_edge) / 2
                        side_real_size = 0.0
                        if 'side_edge_avg' in locals() and side_edge_avg != 0:
                            side_real_size = (dff1 / side_edge_avg) * 25.7
                        side_size_history.append(side_real_size)
                        # 保持历史记录长度为10
                        if len(side_size_history) > 10:
                            side_size_history.pop(0)

                        # 边长尺寸稳定性检测
                        if not side_size_locked:
                            if len(side_size_history) >= 10:
                                side_size_list = list(side_size_history)
                                side_size_range = max(side_size_list) - min(side_size_list)
                                
                                if side_size_range <= 5.0:  # 0.5cm = 5mm
                                    stable_side_size = sum(side_size_list) / len(side_size_list)
                                    side_size_locked = True
                                    print(f"边长尺寸锁定: {stable_side_size:.2f}mm")
                                    serial.write(f"X:({side_real_size:.2f})".encode('utf-8'))  # 发送当前实时尺寸
                        else:
                            # 如果尺寸变动小于0.2cm (2mm)，持续发送当前实时尺寸
                            if abs(side_real_size - stable_side_size) <= 2.0:
                                print(f"边长尺寸稳定，持续发送当前尺寸: {side_real_size:.2f}mm")
                                serial.write(f"X:({side_real_size:.2f})".encode('utf-8'))
                            # 如果尺寸变动超过1cm (10mm)，停止发送并重新检测
                            elif abs(side_real_size - stable_side_size) > 10.0:
                                print("边长尺寸变动超过1cm，重新检测")
                                side_size_locked = False
                                stable_side_size = None
                                side_size_history.clear()
                            # 尺寸变动在0.2cm到1cm之间，不发送但保持锁定状态
                            else:
                                print(f"边长尺寸变动在允许范围内，暂停发送: {side_real_size:.2f}mm")

                        # 显示尺寸信息
                        if side_size_locked and stable_side_size is not None:
                            # 调整坐标和字体参数确保可见
                            cv2.putText(img_bgr, 
                                        f"size: {side_real_size:.2f}mm",  # 显示当前实时尺寸而非stable_side_size
                                        (10, 40),  # 固定在左上角可见位置
                                        cv2.FONT_HERSHEY_SIMPLEX, 
                                        1,  # 适合小屏幕的字体大小
                                        (0, 0, 255),  # 红色文字，对比明显
                                        1)  # 线条粗细

                        # 画轮廓 
                        cv2.drawContours(img_bgr, [offset_approx], 0, (0, 255, 255), 2) 

                        # 画各个角点并添加标签
                        for i, point in enumerate(offset_approx):
                            x, y = point.ravel()
                            cv2.circle(img_bgr, (x, y), 5, (255, 0, 0), 1)
                            cv2.putText(img_bgr, str(i+1), (x+5, y-5),
                                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 0), 1)

            if data == b'\x06':
                # 存储当前帧检测到的所有正方形
                squares = []
                
                for contour in contours: 
                    # 过滤掉太小的轮廓
                    area = cv2.contourArea(contour)
                    if area < 500:  # 提高最小面积阈值
                        continue
                        
                    # 计算参数，多边形逼近
                    epsilon = 0.01 * cv2.arcLength(contour, True) 
                    approx = cv2.approxPolyDP(contour, epsilon, True)  
                    
                    # 只处理四边形
                    if len(approx) == 4:
                        is_sq, avg_side = is_square1(approx)
                        if is_sq:
                            # 计算中心点和边长
                            M = cv2.moments(approx)
                            if M["m00"] != 0:
                                # 添加ROI偏移
                                cx = int(M["m10"] / M["m00"]) + roi_x
                                cy = int(M["m01"] / M["m00"]) + roi_y
                                
                                # 计算正方形边长
                                points = approx.reshape(-1, 2)
                                x_min, y_min = np.min(points, axis=0)
                                x_max, y_max = np.max(points, axis=0)
                                width = x_max - x_min
                                height = y_max - y_min
                                
                                # 使用平均值作为边长
                                side_length = avg_side
                                
                                # 创建带偏移的轮廓
                                offset_approx = approx.copy()
                                offset_approx[:, :, 0] += roi_x  # x坐标偏移
                                offset_approx[:, :, 1] += roi_y  # y坐标偏移
                                
                                # 检查是否已经识别过这个正方形
                                if not is_point_near_recognized(cx, cy):
                                    squares.append((cx, cy, width, height, offset_approx, side_length))
                                else:
                                    # 已识别过的正方形用黄色标记
                                    cv2.drawContours(img_bgr, [offset_approx], 0, (0, 255, 255), 2)
                
                # 如果没有当前处理的正方形，选择一个新的
                if current_square is None and squares:
                    # 选择第一个未处理的正方形
                    cx, cy, width, height, approx, side_length = squares[0]
                    current_square = [cx, cy, width, height, 0, None, side_length]  # 添加边长信息
                    print(f"选择新正方形: 中心({cx},{cy}), 大小({width}x{height}), 边长: {side_length:.2f}像素")
                
                # 如果有当前处理的正方形，进行OCR识别
                if current_square is not None:
                    cx, cy, width, height, consecutive_count, last_digit, side_length = current_square
                    
                    # 设置ROI区域，缩小一点以更聚焦于数字
                    scale = 0.8  # 缩放因子，小于1表示缩小
                    padding = 0  # 移除额外的padding

                    # 计算缩小后的宽度和高度
                    scaled_width = int(width * scale)
                    scaled_height = int(height * scale)

                    # 计算新的ROI坐标，保持中心点不变
                    roi_x_ocr = max(0, cx - scaled_width//2)
                    roi_y_ocr = max(0, cy - scaled_height//2)
                    roi_w = scaled_width
                    roi_h = scaled_height
                    
                    # 在ROI区域内进行OCR
                    img_maix, digit = process_ocr_in_roi(img_maix, roi_x_ocr, roi_y_ocr, roi_w, roi_h)
                    # 特殊处理：如果检测到的是's'，将其视为'5'
                    if digit and digit.lower() == 's':
                        print("检测到's'，视为'5'")
                        digit = "5"
                    # 显示当前识别的数字
                    if digit:
                        print(f"检测到数字: {digit}, 连续次数: {consecutive_count}")
                        print('1',target_number,digit)
                        # 检查是否与目标数字匹配
                        if digit == target_number:
                            print(f"找到目标数字 {target_number}! 正方形边长: {side_length:.2f}像素")
                            target_square_side_length = side_length
                            dff3=((side_length / detected_width) * 17) if detected_width != 0 else 0
                            cv2.putText(img_bgr, f"{dff3}", (10,50), 
                            cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0, 0, 255), 3)
                            serial.write(f"X:({dff3:.2f})".encode('utf-8'))
                            if squares and len(squares) > 0:
                            # 在图像上特别标记这个正方形
                                cv2.drawContours(img_bgr, [squares[0][4]], 0, (0, 255, 0), 3)  # 绿色粗线

                        # 如果与上次识别的数字相同，增加连续计数
                        if digit == last_digit:
                            current_square[4] += 1  # 增加连续识别次数
                        else:
                            current_square[4] = 1  # 重置连续识别次数
                            current_square[5] = digit  # 更新上次识别的数字
                        
                        # 如果连续2次识别到相同数字，标记该正方形
                        if current_square[4] >= 2:
                            recognized_squares.append([cx, cy, digit, True, side_length])
                            print(f"正方形已标记! 位置({cx},{cy}), 数字: {digit}, 边长: {side_length:.2f}像素")
                            
                            # 重置当前处理的正方形
                            current_square = None
                    else:
                        # 如果没有检测到数字，重置连续计数
                        current_square[4] = 0
                        current_square[5] = None
                
                # 在原图上标记已识别的正方形
                for square in recognized_squares:
                    cx, cy, digit, marked, side_length = square
                    cv2.circle(img_bgr, (cx, cy), 10, (0, 0, 255), -1)
                    # 使用红色绘制已识别的数字，字体更大更粗
                    cv2.putText(img_bgr, f"{digit}", (cx+1, cy+1), 
                            cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0, 0, 255), 3)
                

                
                # 如果找到了目标正方形，显示边长信息
                if target_square_side_length is not None:
                    cv2.putText(img_bgr, f"s: {target_square_side_length:.2f}px", 
                            (20, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)

    if data ==b'\x05':
        print('5')
        # 修改：使用基于smallest_contour的动态ROI（如果存在，否则回退到固定ROI）
        if dynamic_roi is not None:
            dyn_x = dynamic_roi['x']
            dyn_y = dynamic_roi['y']
            dyn_w = dynamic_roi['w']
            dyn_h = dynamic_roi['h']
            dyn_roi_img = img_bgr[dyn_y:dyn_y + dyn_h, dyn_x:dyn_x + dyn_w]
            print(f"使用动态ROI: x={dyn_x}, y={dyn_y}, w={dyn_w}, h={dyn_h}")
        else:
            dyn_roi_img = roi  # 回退到固定ROI
            dyn_x, dyn_y = roi_x, roi_y  # 使用固定偏移
        
        min_side_length, all_sides = process_frame_for_complex_squares(img_bgr, dynamic_roi)
        # 处理检测到的边长
        if min_side_length is not None:
            print(f"检测到的最小边长: {min_side_length:.2f}像素")
            
            # 添加到历史记录
            side_length_history.append(min_side_length)
            # 只保留最近10帧的数据
            if len(side_length_history) > 10:
                side_length_history.pop(0)
                
            # 如果有足够的历史数据，计算稳定的边长
            if len(side_length_history) >= 5:
                # 计算平均值和标准差
                avg_length = sum(side_length_history) / len(side_length_history)
                std_dev = (sum((x - avg_length) ** 2 for x in side_length_history) / len(side_length_history)) ** 0.5
                
                # 如果标准差足够小，认为边长稳定
                if std_dev < 2.0:  # 可以根据需要调整阈值
                    stable_side_length = avg_length
                    size1= ((stable_side_length / detected_width) * 17) if detected_width != 0 else 0
                    print(f"稳定的边长: {stable_side_length:.2f}像素")
                    print(f"最小的尺寸为: {size1:.2f}cm")
                    serial.write(f"X:({size1:.2f})".encode('utf-8'))
                    print('nb')

            # 显示所有检测到的边长
            if all_sides:
                print(f"所有检测到的边长: {[f'{s:.2f}' for s in all_sides]}")
    if data == b'\x08':
        reset_all_detection_variables()
    # 显示 ROI 区域（绘制红色矩形边框）
    cv2.rectangle(img_bgr, (roi_x, roi_y), (roi_x + roi_size, roi_y + roi_size), (0, 0, 255), 2)
    # 显示目标数字信息
    cv2.putText(img_bgr, f"number: {target_number}", (200, 20), 
            cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 0, 0), 2)
    # 显示图像
    img_show = image.cv2image(img_bgr, copy=False)
    disp.show(img_show)
